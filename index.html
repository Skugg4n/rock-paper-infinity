<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sax, Sten, Påse - Upplåsning</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style id="dynamic-styles"></style> <!-- För dynamiska animationstider -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            background-color: #f1f5f9; /* bg-slate-200 */
        }
        .btn { transition: all 0.2s ease-in-out; pointer-events: auto; cursor: pointer; }
        .btn > * { pointer-events: none; }
        .choice-btn:hover:not(:disabled) { transform: translateY(-4px); background-color: #ffffff; }
        .choice-btn:disabled { cursor: not-allowed; opacity: 0.5; }
        
        .upgrade-btn { position: relative; }
        .upgrade-btn.toggled { background-color: #e2e8f0; /* bg-slate-300 */ box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05); }
        .upgrade-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .upgrade-btn:disabled:not(.purchased) { opacity: 0.4; cursor: not-allowed; }

        .lucide { width: 32px; height: 32px; stroke-width: 1.5; }
        .lucide-lg { width: 56px; height: 56px; transition: all 0.3s ease-in-out; }
        
        .currency-display { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
        .lucide-star-small { width: 8px; height: 8px; }
        .lucide-gem-large { width: 32px; height: 32px; }
        .lucide-gem-medium { width: 16px; height: 16px; }
        .lucide-crown-xl { width: 40px; height: 40px; }
        .dot { width: 8px; height: 8px; background-color: #cbd5e1; border-radius: 9999px; }

        .win-ring {
            position: absolute;
            top: -8px; left: -8px; right: -8px; bottom: -8px;
            border: 3px solid #334155;
            border-radius: 9999px;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .win-ring.visible { opacity: 1; transform: scale(1); }

        .progress-ring-bg { stroke: #e2e8f0; }
        .progress-ring-fg {
            stroke: #475569;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.3s ease;
        }

        #tooltip {
            position: absolute;
            display: none;
            background-color: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        @keyframes reveal { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .reveal-item { animation: reveal 0.4s ease-out forwards; }
        @keyframes pop { 0% { transform: scale(0); opacity: 0; } 70% { transform: scale(1.2); } 100% { transform: scale(1); opacity: 1; } }
        .pop-item { animation: pop 0.5s cubic-bezier(0.77, 0, 0.175, 1) forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .7; } }
        .pulse { animation: pulse 1s infinite cubic-bezier(0.4, 0, 0.6, 1); }
        .countdown-pop { animation-name: pop; animation-timing-function: ease-in-out; }

        #player-zone { position: relative; z-index: 10; }

        .small-icons .lucide-lg { width: 32px; height: 32px; }
        .small-icons .win-ring { top: -4px; left: -4px; right: -4px; bottom: -4px; border-width: 2px; }

        #meta-board {
            border: 4px solid #475569;
            box-shadow: 0 0 20px rgba(71, 85, 105, 0.5);
            overflow: hidden;
        }
        @keyframes meta-pulse { 0%, 100% { border-color: #475569; } 50% { border-color: #0ea5e9; } }
        .meta-active { animation: meta-pulse 1s infinite; }
        
        #collapse-foam-btn {
            position: relative;
            background-color: #e2e8f0;
            border: 2px solid #94a3b8;
        }
        #collapse-foam-btn.ready {
            background-color: #fff;
            border-color: #475569;
            cursor: pointer;
        }
        #collapse-foam-btn.ready:hover {
            transform: translateY(-2px);
        }
        #collapse-foam-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #67e8f9;
            transition: height 0.3s ease-in-out;
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- Resurser på vänster sida -->
    <div class="absolute top-8 left-4 md:left-8 flex flex-col items-start gap-4">
        <div id="win-tracker" class="flex flex-col items-start gap-3"></div>
        <div class="flex items-end gap-2">
            <div id="energy-container" class="w-4 h-32 bg-slate-300 rounded-full overflow-hidden p-1 flex flex-col justify-end">
                <div id="energy-fill" class="w-full bg-emerald-500 rounded-full transition-all duration-300"></div>
            </div>
            <div id="reserve-energy-container" class="w-6 h-40 bg-slate-300 rounded-full overflow-hidden p-1 flex flex-col justify-end">
                <div id="reserve-energy-fill" class="w-full bg-sky-500 rounded-full transition-all duration-300"></div>
            </div>
        </div>
        <div id="quantum-foam-container" class="hidden w-16 flex flex-col items-center gap-2">
            <button id="collapse-foam-btn" onclick="collapseFoam()" class="btn w-12 h-12 rounded-full flex justify-center items-center overflow-hidden" disabled>
                <div id="collapse-foam-fill" style="height: 0%;"></div>
                <i data-lucide="zap" class="relative w-6 h-6 text-slate-600"></i>
            </button>
        </div>
        <div id="sps-container" class="hidden flex items-center gap-2 text-slate-500">
            <span id="sps-value" class="font-bold text-lg font-mono">0.0</span>
            <div class="flex items-center">
                <i data-lucide="star" class="w-4 h-4"></i>
                <span class="font-bold text-sm mx-0.5">/</span>
                <i data-lucide="timer" class="w-4 h-4"></i>
            </div>
        </div>
        <div id="eps-container" class="hidden flex items-center gap-2 text-slate-500">
            <span id="eps-value" class="font-bold text-lg font-mono">0.0</span>
            <div class="flex items-center">
                <i data-lucide="zap-off" class="w-4 h-4"></i>
                <span class="font-bold text-sm mx-0.5">/</span>
                <i data-lucide="timer" class="w-4 h-4"></i>
            </div>
        </div>
         <div id="egps-container" class="hidden flex items-center gap-2 text-slate-500">
            <span id="egps-value" class="font-bold text-lg font-mono">0.0</span>
            <div class="flex items-center">
                <i data-lucide="atom" class="w-4 h-4"></i>
                <span class="font-bold text-sm mx-0.5">/</span>
                <i data-lucide="timer" class="w-4 h-4"></i>
            </div>
        </div>
    </div>

    <!-- Huvudcontainer för spelet -->
    <div class="w-full max-w-2xl mx-auto p-4 flex flex-col h-[100svh]">
        <header class="h-16 flex-shrink-0"></header> <!-- Spacer -->
        
        <main id="game-board-container" class="pointer-events-none flex-grow grid grid-cols-1 items-center justify-center gap-4">
            <!-- Spelbord kommer att injiceras här av JS -->
        </main>

        <footer id="player-zone" class="h-40 flex-shrink-0 flex flex-col justify-end items-center gap-4 pb-4">
            <div id="player-controls-container" class="grid grid-cols-5 gap-2 w-full max-w-sm">
                <button data-choice="rock" class="btn choice-btn bg-slate-50 w-16 h-16 rounded-full shadow-md flex justify-center items-center"><i data-lucide="gem"></i></button>
                <button data-choice="paper" class="btn choice-btn bg-slate-50 w-16 h-16 rounded-full shadow-md flex justify-center items-center"><i data-lucide="file-text"></i></button>
                <button data-choice="scissors" class="btn choice-btn bg-slate-50 w-16 h-16 rounded-full shadow-md flex justify-center items-center"><i data-lucide="scissors"></i></button>
                <button id="manualRecharge" data-upgrade="manualRecharge" class="invisible btn upgrade-btn bg-slate-50 w-16 h-16 rounded-full shadow-md flex justify-center items-center"><i data-lucide="battery-charging"></i></button>
                <button id="autoPlay" data-upgrade="autoPlay" class="invisible btn upgrade-btn bg-slate-50 w-16 h-16 rounded-full shadow-md flex justify-center items-center"><i data-lucide="repeat-2"></i></button>
            </div>
        </footer>
    </div>

    <!-- Uppgraderingsknappar -->
    <div class="absolute bottom-8 right-8 flex items-end gap-3">
        <div id="downgrade-tray" class="flex flex-col gap-3"></div>
        <div id="upgrade-tray" class="flex flex-col gap-3">
            <button id="speed" data-upgrade="speed" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg">
                <svg class="absolute inset-0 w-full h-full" viewBox="0 0 36 36">
                    <circle class="progress-ring-bg" cx="18" cy="18" r="16" fill="none" stroke-width="3"></circle>
                    <circle id="speed-progress" class="progress-ring-fg" cx="18" cy="18" r="16" fill="none" stroke-width="3" stroke-dasharray="100.5" stroke-dashoffset="100.5"></circle>
                </svg>
                <i id="speed-icon" data-lucide="chevrons-right" class="relative w-6 h-6 text-slate-600"></i>
            </button>
            <button id="energyGenerator" data-upgrade="energyGenerator" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg">
                <svg class="absolute inset-0 w-full h-full" viewBox="0 0 36 36">
                    <circle class="progress-ring-bg" cx="18" cy="18" r="16" fill="none" stroke-width="3"></circle>
                    <circle id="energy-gen-progress" class="progress-ring-fg" cx="18" cy="18" r="16" fill="none" stroke-width="3" stroke-dasharray="100.5" stroke-dashoffset="100.5"></circle>
                </svg>
                <i data-lucide="atom" class="relative w-6 h-6 text-slate-600"></i>
            </button>
            <button id="buyBattery" data-upgrade="buyBattery" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg"><i data-lucide="battery-plus" class="relative w-6 h-6 text-slate-600"></i></button>
            <button id="luck" data-upgrade="luck" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg"><i data-lucide="clover" class="relative w-6 h-6 text-slate-600"></i></button>
            <button id="addGameBoard" data-upgrade="addGameBoard" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg">
                <svg class="absolute inset-0 w-full h-full" viewBox="0 0 36 36">
                    <circle class="progress-ring-bg" cx="18" cy="18" r="16" fill="none" stroke-width="3"></circle>
                    <circle id="add-board-progress" class="progress-ring-fg" cx="18" cy="18" r="16" fill="none" stroke-width="3" stroke-dasharray="100.5" stroke-dashoffset="100.5"></circle>
                </svg>
                <i data-lucide="copy" class="relative w-6 h-6 text-slate-600"></i>
            </button>
            <button id="mergeGameBoard" data-upgrade="mergeGameBoard" class="invisible btn upgrade-btn bg-white p-3 rounded-full shadow-lg"><i data-lucide="combine" class="relative w-6 h-6 text-slate-600"></i></button>
        </div>
    </div>

    <!-- Debug-meny -->
    <div id="debug-trigger" class="absolute bottom-0 left-0 w-16 h-16 cursor-pointer"></div>
        <div id="debug-menu" class="hidden absolute bottom-16 left-4 flex flex-col gap-2 bg-slate-700 p-2 rounded-lg shadow-xl z-20">
        <div class="text-white text-xs font-bold border-b border-slate-600 pb-1 mb-1">Stjärnor</div>
        <button onclick="addStars(1)" class="text-white text-xs font-bold bg-slate-600 hover:bg-slate-500 rounded px-2 py-1">+1 ★</button>
        <button onclick="addStars(100)" class="text-white text-xs font-bold bg-slate-600 hover:bg-slate-500 rounded px-2 py-1">+100 ★</button>
        <button onclick="addStars(1000)" class="text-white text-xs font-bold bg-slate-600 hover:bg-slate-500 rounded px-2 py-1">+1k ★</button>
        <button onclick="addStars(10000)" class="text-white text-xs font-bold bg-slate-600 hover:bg-slate-500 rounded px-2 py-1">+10k ★</button>
        <div class="text-white text-xs font-bold border-b border-slate-600 pb-1 my-1">Hastighet</div>
        <div class="flex items-center justify-between gap-2">
             <button onclick="changeSpeed(-1)" class="text-white text-lg font-bold bg-slate-600 hover:bg-slate-500 rounded w-6 h-6">-</button>
             <span id="debug-speed" class="text-white text-xs font-mono">⚡︎ 1x</span>
             <button onclick="changeSpeed(1)" class="text-white text-lg font-bold bg-slate-600 hover:bg-slate-500 rounded w-6 h-6">+</button>
        </div>
        <div class="text-white text-xs font-bold border-b border-slate-600 pb-1 my-1">Spel</div>
        <div id="debug-games-played" class="text-white text-xs font-mono text-center">0</div>
    </div>
    
    <div id="tooltip"></div>

    <script>
        // DOM-element
        const gameBoardContainer = document.getElementById('game-board-container');
        const choiceButtons = document.querySelectorAll('#player-controls-container .choice-btn');
        const winTracker = document.getElementById('win-tracker');
        const energyFillEl = document.getElementById('energy-fill');
        const reserveEnergyFillEl = document.getElementById('reserve-energy-fill');
        const quantumFoamContainer = document.getElementById('quantum-foam-container');
        const collapseFoamBtn = document.getElementById('collapse-foam-btn');
        const collapseFoamFill = document.getElementById('collapse-foam-fill');
        const spsContainer = document.getElementById('sps-container');
        const spsValue = document.getElementById('sps-value');
        const epsContainer = document.getElementById('eps-container');
        const epsValue = document.getElementById('eps-value');
        const egpsContainer = document.getElementById('egps-container');
        const egpsValue = document.getElementById('egps-value');
        const debugTrigger = document.getElementById('debug-trigger');
        const debugMenu = document.getElementById('debug-menu');
        const debugSpeedEl = document.getElementById('debug-speed');
        const debugGamesPlayedEl = document.getElementById('debug-games-played');
        const dynamicStyles = document.getElementById('dynamic-styles');
        const speedProgressCircle = document.getElementById('speed-progress');
        const energyGenProgressCircle = document.getElementById('energy-gen-progress');
        const addBoardProgressCircle = document.getElementById('add-board-progress');
        const downgradeTray = document.getElementById('downgrade-tray');
const tooltip = document.getElementById('tooltip');

        // Spelvariabler
        let starBalance = 0;
        let totalStarsEarned = 0;
        let totalGamesPlayed = 0;
        let energy = 100;
        let reserveEnergy = 0;
        const MAX_ENERGY = 100;
        const MAX_RESERVE_ENERGY = 1500;
        let autoPlayInterval = null;
        let autoPlayWantsToRun = false; 
        let gameSpeed = 1;
        let winChance = 1/3;
        let lastTick = performance.now();
        let gameBoards = [];
        let isMetaBoardActive = false;
        let starMultiplier = 1;
        let quantumFoam = 0;
        const MAX_QUANTUM_FOAM = 1000;
        const HYPER_SPEED_THRESHOLD = 10;
        
        const upgrades = {
            autoPlay: {
                cost: 5, purchased: false, unlocksAt: 2, unlocks: ['speed'],
                element: document.getElementById('autoPlay'),
                purchase: function() { this.element.classList.remove('fade-in'); }
            },
            manualRecharge: {
                cost: 1, purchased: false, unlocksAt: 15, unlocks: [],
                element: document.getElementById('manualRecharge'),
                purchase: function() { energy = Math.min(MAX_ENERGY, energy + 10); }
            },
            speed: {
                level: 0, maxLevel: 55,
                cost: () => 10 + Math.floor(upgrades.speed.level * 2),
                unlocks: [],
                element: document.getElementById('speed'),
                purchase: function() {
                    this.level++;
                    gameSpeed += 1;
                    this.element.classList.add('pop-item');
                    setTimeout(() => this.element.classList.remove('pop-item'), 500);
                }
            },
            buyBattery: {
                cost: 100, consumable: true, 
                unlocksAt: 50, unlocks: [],
                element: document.getElementById('buyBattery'),
                purchase: function() {
                    reserveEnergy = Math.min(MAX_RESERVE_ENERGY, reserveEnergy + 700);
                    this.element.classList.add('pop-item');
                    setTimeout(() => this.element.classList.remove('pop-item'), 500);
                }
            },
            luck: {
                cost: 50, purchased: false, unlocksAtGames: 100, unlocks: [],
                element: document.getElementById('luck'),
                purchase: function() {
                    winChance = 0.5;
                    this.element.style.display = 'none';
                }
            },
            energyGenerator: {
                level: 0, maxLevel: 100,
                cost: () => 50 + Math.floor(upgrades.energyGenerator.level * 5),
                unlocksAtSPS: 50, unlocks: [],
                element: document.getElementById('energyGenerator'),
                purchase: function() { this.level++; }
            },
            addGameBoard: {
                level: 0, maxLevel: 8,
                cost: () => 100 + Math.floor(upgrades.addGameBoard.level * 25),
                unlocksAt: 100, unlocks: ['mergeGameBoard'],
                element: document.getElementById('addGameBoard'),
                purchase: function() {
                    if (this.level >= this.maxLevel) return;
                    this.level++;
                    createGameBoard();
                }
            },
            // FIX: Knappen låses inte längre upp vid start
            mergeGameBoard: {
                cost: 1000, purchased: false,
                element: document.getElementById('mergeGameBoard'),
                purchase: function() {
                    this.purchased = true;
                    mergeToMetaBoard();
                }
            }
        };

const choices = ['rock', 'paper', 'scissors'];
const iconMap = { rock: 'gem', paper: 'file-text', scissors: 'scissors' };

        function setupButtons() {
            document.querySelectorAll('[data-choice]').forEach(btn => {
                const choice = btn.dataset.choice;
                btn.addEventListener('click', () => playGame(choice));
                btn.addEventListener('mouseenter', () => showTooltip(btn, 'choice'));
                btn.addEventListener('mouseleave', hideTooltip);
            });
            document.querySelectorAll('[data-upgrade]').forEach(btn => {
                const key = btn.dataset.upgrade;
                btn.addEventListener('click', () => handleUpgradeClick(key));
                btn.addEventListener('mouseenter', () => showTooltip(btn, key));
                btn.addEventListener('mouseleave', hideTooltip);
            });
        }

        function createGameBoard() {
            const boardId = `game-board-${gameBoards.length + 1}`;
            const board = document.createElement('div');
            board.id = boardId;
            board.className = 'bg-white rounded-2xl shadow-md aspect-square w-full h-auto flex flex-col justify-around items-center p-4 transition-all';
            board.innerHTML = `
                <div class="relative h-20 w-20 flex justify-center items-center">
                    <div class="computer-result-icon text-slate-400"></div>
                    <div class="win-ring computer-ring"></div>
                </div>
                <div class="relative h-20 w-20 flex justify-center items-center">
                    <div class="player-result-icon text-slate-400"></div>
                    <div class="win-ring player-ring"></div>
                </div>
            `;
            gameBoardContainer.appendChild(board);
            gameBoards.push({
                id: boardId,
                element: board,
                isAnimating: false,
                computerEl: board.querySelector('.computer-result-icon'),
                playerEl: board.querySelector('.player-result-icon'),
                computerRing: board.querySelector('.computer-ring'),
                playerRing: board.querySelector('.player-ring')
            });
            adjustBoardLayout();
        }
        
        function adjustBoardLayout() {
            const count = gameBoards.length;
            if (isMetaBoardActive) return;

            let cols = 1;
            if (count > 1) cols = 2;
            if (count > 4) cols = 3;
            gameBoardContainer.className = `flex-grow grid grid-cols-${cols} items-center justify-center gap-4`;
            
            if (count > 4) {
                gameBoardContainer.classList.add('small-icons');
            } else {
                gameBoardContainer.classList.remove('small-icons');
            }
        }

        function mergeToMetaBoard() {
            isMetaBoardActive = true;
            starMultiplier = 10;
            gameBoards.forEach(board => board.element.style.display = 'none');
            
            let metaBoard = document.getElementById('meta-board');
            if (!metaBoard) {
                metaBoard = document.createElement('div');
                metaBoard.id = 'meta-board';
                metaBoard.className = 'bg-white rounded-2xl shadow-lg aspect-square w-full h-auto flex justify-center items-center p-4 transition-all relative';
                metaBoard.innerHTML = `
                    <svg width="100%" height="100%" viewBox="0 0 200 200">
                        <defs>
                            <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#0ea5e9;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#67e8f9;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <circle cx="100" cy="100" r="80" stroke="url(#grad1)" stroke-width="4" fill="none">
                            <animateTransform attributeName="transform" type="rotate" from="0 100 100" to="360 100 100" dur="10s" repeatCount="indefinite" />
                        </circle>
                        <circle cx="100" cy="100" r="60" stroke="url(#grad1)" stroke-width="2" fill="none" stroke-dasharray="10 10">
                             <animateTransform attributeName="transform" type="rotate" from="360 100 100" to="0 100 100" dur="15s" repeatCount="indefinite" />
                        </circle>
                    </svg>
                `;
                gameBoardContainer.innerHTML = '';
                gameBoardContainer.className = 'flex-grow grid grid-cols-1 items-center justify-center gap-4 max-w-sm mx-auto';
                gameBoardContainer.appendChild(metaBoard);
            }
            metaBoard.style.display = 'flex';
            metaBoard.classList.add('meta-active');
            quantumFoamContainer.classList.remove('hidden');
        }

        function init() {
            createGameBoard();
            setupButtons();
            lucide.createIcons();
            updateAnimationSpeed();
            updateUI();
            debugTrigger.addEventListener('click', () => debugMenu.classList.toggle('hidden'));
            setInterval(passiveTick, 1000);
        }
        
        function passiveTick() {
            const energyGen = upgrades.energyGenerator.level * 5;
            if (energyGen > 0) {
                energy = Math.min(MAX_ENERGY, energy + energyGen);
                reserveEnergy = Math.min(MAX_RESERVE_ENERGY, reserveEnergy + energyGen);
            }
            manageAutoPlay();
            updateUI();
        }

        function updateAnimationSpeed() {
            const animationDuration = 1.2 / gameSpeed;
            dynamicStyles.innerHTML = `
                .countdown-pop { animation-duration: ${animationDuration / 3}s; }
                .reveal-item { animation-duration: ${0.4 / gameSpeed}s; }
            `;
            debugSpeedEl.textContent = `⚡︎ ${gameSpeed}x`;
            if (autoPlayInterval) restartAutoPlay();
        }

        function getVisibleDots() {
            if (totalStarsEarned >= 30) return 100;
            if (totalStarsEarned >= 10) return 20;
            if (totalStarsEarned >= 5) return 10;
            return 5;
        }

        function updateWinVisuals() {
            winTracker.innerHTML = '';
            const crowns = Math.floor(starBalance / 10000);
            const gems = Math.floor((starBalance % 10000) / 100);
            const smallStars = starBalance % 100;
            
            if (crowns > 0) {
                 const container = document.createElement('div');
                container.className = 'flex flex-wrap gap-1 items-center';
                for (let i = 0; i < crowns; i++) container.innerHTML += '<div><i data-lucide="crown" class="lucide-crown-xl text-slate-800"></i></div>';
                winTracker.appendChild(container);
            }
            if (gems > 0) {
                const container = document.createElement('div');
                container.className = 'grid grid-cols-10 gap-1 items-center';
                const gemSizeClass = gems > 5 ? 'lucide-gem-medium' : 'lucide-gem-large';
                for (let i = 0; i < gems; i++) {
                    container.innerHTML += `<div><i data-lucide="gem" class="${gemSizeClass} text-slate-800"></i></div>`;
                }
                winTracker.appendChild(container);
            }

            const dotsToShow = getVisibleDots();
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid grid-cols-10 gap-1';
            for (let i = 0; i < dotsToShow; i++) {
                if (i < smallStars) gridContainer.innerHTML += '<div><i data-lucide="star" class="lucide-star-small text-slate-800 fill-current"></i></div>';
                else gridContainer.innerHTML += '<div class="dot"></div>';
            }
            winTracker.appendChild(gridContainer);
            
            lucide.createIcons();
        }
        
        function getSPS() {
            const boardMultiplier = isMetaBoardActive ? 9 : gameBoards.length;
            const baseSPS = (gameSpeed < HYPER_SPEED_THRESHOLD)
                ? (1000 / (((1.2 / gameSpeed) * 1000 + 450) / boardMultiplier)) * winChance
                : (gameSpeed * boardMultiplier) * winChance;
            return baseSPS * starMultiplier;
        }
        
        function updateRateDisplays() {
            const sps = getSPS();
            if (sps > 0.1) {
                spsContainer.classList.remove('hidden');
                spsValue.textContent = sps.toFixed(1);
            } else {
                spsContainer.classList.add('hidden');
            }
            
            const boardMultiplier = isMetaBoardActive ? 9 : gameBoards.length;
            const eps = gameSpeed * boardMultiplier;
            if (autoPlayInterval) {
                epsContainer.classList.remove('hidden');
                epsValue.textContent = eps.toFixed(1);
            } else {
                epsContainer.classList.add('hidden');
            }

            const egps = upgrades.energyGenerator.level * 5;
            if (egps > 0) {
                egpsContainer.classList.remove('hidden');
                egpsValue.textContent = egps.toFixed(1);
            } else {
                egpsContainer.classList.add('hidden');
            }
        }

        function updateSellButtons() {
            downgradeTray.innerHTML = '';
            if (upgrades.energyGenerator.level < upgrades.energyGenerator.maxLevel) return;

            const sellableUpgrades = ['speed', 'addGameBoard'];
            sellableUpgrades.forEach(key => {
                const upgrade = upgrades[key];
                if (upgrade.level > 0 && !isMetaBoardActive) {
                    const btn = document.createElement('button');
                    btn.className = 'btn bg-white p-3 rounded-full shadow-lg flex items-center justify-center';
                    btn.onclick = () => handleSellClick(key);
                    btn.innerHTML = `<i data-lucide="minus" class="relative w-6 h-6 text-red-500"></i>`;
                    downgradeTray.appendChild(btn);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'w-12 h-12';
                    downgradeTray.appendChild(placeholder);
                }
            });
            lucide.createIcons();
        }

        function updateUI() {
            updateWinVisuals();
            updateRateDisplays();
            updateSellButtons();
            debugGamesPlayedEl.textContent = Math.floor(totalGamesPlayed);

            const energyPercent = (energy / MAX_ENERGY) * 100;
            energyFillEl.style.height = `${energyPercent}%`;
            const reservePercent = (reserveEnergy / MAX_RESERVE_ENERGY) * 100;
            reserveEnergyFillEl.style.height = `${reservePercent}%`;

            if (energy <= 0) {
                energyFillEl.classList.add('bg-red-500');
                energyFillEl.classList.remove('bg-emerald-500');
            } else {
                energyFillEl.classList.remove('bg-red-500');
                energyFillEl.classList.add('bg-emerald-500');
            }

            for (const key in upgrades) {
                const upgrade = upgrades[key];
                
                let isUnlocked = (upgrade.unlocksAt === 0 && key !== 'mergeGameBoard') || // FIX: Gäller ej mergeGameBoard
                                 (upgrade.unlocksAt > 0 && totalStarsEarned >= upgrade.unlocksAt) ||
                                 (upgrade.unlocksAtGames > 0 && totalGamesPlayed >= upgrade.unlocksAtGames) ||
                                 (upgrade.unlocksAtSPS > 0 && getSPS() >= upgrade.unlocksAtSPS) ||
                                 Object.keys(upgrades).some(parentKey => {
                                     const parent = upgrades[parentKey];
                                     const parentUnlocked = (parent.level !== undefined && parent.level >= parent.maxLevel) || parent.purchased;
                                     return parent.unlocks && parent.unlocks.includes(key) && parentUnlocked;
                                 });

                if (isUnlocked) {
                    if (isMetaBoardActive && (key === 'addGameBoard' || key === 'mergeGameBoard')) {
                        upgrade.element.classList.add('invisible');
                    } else {
                        upgrade.element.classList.remove('invisible');
                    }

                    const currentCost = typeof upgrade.cost === 'function' ? upgrade.cost() : upgrade.cost;

                    if (upgrade.level !== undefined) {
                        upgrade.element.disabled = (starBalance < currentCost) || (upgrade.level >= upgrade.maxLevel);
                        if (upgrade.level >= upgrade.maxLevel) upgrade.element.classList.add('purchased');
                    } else if (upgrade.consumable) {
                        upgrade.element.disabled = starBalance < currentCost;
                    } else { 
                        upgrade.element.disabled = (starBalance < currentCost) || upgrade.purchased;
                        if (upgrade.purchased) upgrade.element.classList.add('purchased');
                    }
                } else {
                    upgrade.element.classList.add('invisible');
                }
            }
            
            const circumference = 100.5;

            const speedUpgrade = upgrades.speed;
            speedProgressCircle.style.strokeDashoffset = circumference * (1 - (speedUpgrade.level / speedUpgrade.maxLevel));

            const energyGenUpgrade = upgrades.energyGenerator;
            energyGenProgressCircle.style.strokeDashoffset = circumference * (1 - (energyGenUpgrade.level / energyGenUpgrade.maxLevel));
            
            const addBoardUpgrade = upgrades.addGameBoard;
            addBoardProgressCircle.style.strokeDashoffset = circumference * (1 - (addBoardUpgrade.level / addBoardUpgrade.maxLevel));
            
            if(isMetaBoardActive) {
                const foamPercent = (quantumFoam / MAX_QUANTUM_FOAM) * 100;
                collapseFoamFill.style.height = `${foamPercent}%`;
                collapseFoamBtn.disabled = quantumFoam < MAX_QUANTUM_FOAM;
                collapseFoamBtn.classList.toggle('ready', quantumFoam >= MAX_QUANTUM_FOAM);
            }

            lucide.createIcons();
        }

        // FIX: Återställd funktion
        async function runCountdownAnimation(board) {
            const duration = (1.2 / gameSpeed / 3) * 1000;
            let countdownIcons = [];

            if (gameSpeed <= 5) countdownIcons = ["III", "II", "I"];
            else if (gameSpeed <= 6) countdownIcons = ["III", "II"];
            else if (gameSpeed <= 7) countdownIcons = ["III"];
            else if (gameSpeed <= HYPER_SPEED_THRESHOLD) countdownIcons = ["I"];
            
            const svgMap = {
                "III": `<svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 56 56" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" class="lucide-lg countdown-pop text-slate-400"><line x1="16" y1="14" x2="16" y2="42"></line><line x1="28" y1="14" x2="28" y2="42"></line><line x1="40" y1="14" x2="40" y2="42"></line></svg>`,
                "II": `<svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 56 56" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" class="lucide-lg countdown-pop text-slate-400"><line x1="22" y1="14" x2="22" y2="42"></line><line x1="34" y1="14" x2="34" y2="42"></line></svg>`,
                "I": `<svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 56 56" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" class="lucide-lg countdown-pop text-slate-400"><line x1="28" y1="14" x2="28" y2="42"></line></svg>`
            };
            
            for (const icon of countdownIcons) {
                board.computerEl.innerHTML = svgMap[icon];
                board.playerEl.innerHTML = svgMap[icon];
                await new Promise(resolve => setTimeout(resolve, duration));
            }
        }

        function consumeEnergy(amount = 1) {
            if (reserveEnergy >= amount) {
                reserveEnergy -= amount;
            } else {
                const remaining = amount - reserveEnergy;
                reserveEnergy = 0;
                energy = Math.max(0, energy - remaining);
            }
        }

        function hasEnergy() {
            return energy > 0 || reserveEnergy > 0;
        }

        async function playGame(playerChoice, board = gameBoards[0]) {
            if (isMetaBoardActive || board.isAnimating || !hasEnergy()) return;
            board.isAnimating = true;
            consumeEnergy();
            totalGamesPlayed++;
            
            board.computerRing.classList.remove('visible');
            board.playerRing.classList.remove('visible');
            choiceButtons.forEach(btn => btn.disabled = true);

            if (gameSpeed >= HYPER_SPEED_THRESHOLD && autoPlayInterval) {
                showResult(playerChoice, board, true);
            } else {
                await runCountdownAnimation(board);
                showResult(playerChoice, board, false);
            }
        }

        function showResult(playerChoice, board, instant = false) {
            const computerChoice = choices[Math.floor(Math.random() * choices.length)];
            let result = 'tie';
            
            if (Math.random() < winChance) result = 'win';
            else if (Math.random() < 0.5) result = 'lose';

            const revealClass = instant ? '' : 'reveal-item';
            board.playerEl.innerHTML = `<div class="${revealClass}"><i data-lucide="${iconMap[playerChoice]}" class="lucide-lg text-slate-800"></i></div>`;
            board.computerEl.innerHTML = `<div class="${revealClass}"><i data-lucide="${iconMap[computerChoice]}" class="lucide-lg text-slate-800"></i></div>`;

            if (result === 'win') {
                const starGain = 1 * starMultiplier;
                starBalance += starGain;
                totalStarsEarned += starGain;
                board.playerRing.classList.add('visible');
            } else if (result === 'lose') {
                board.computerRing.classList.add('visible');
            }
            
            lucide.createIcons();
            updateUI();
            
            if (!hasEnergy() && autoPlayInterval) stopAutoPlayInterval();

            setTimeout(() => {
                board.isAnimating = false;
                if (!autoPlayInterval) choiceButtons.forEach(btn => btn.disabled = !hasEnergy());
                updateUI();
            }, instant ? 50 : 400);
        }
        
        function handleUpgradeClick(key) {
            const upgrade = upgrades[key];
            if (key === 'autoPlay' && upgrade.purchased) {
                toggleAutoPlayState();
                return;
            }
            
            const currentCost = (typeof upgrade.cost === 'function') ? upgrade.cost() : upgrade.cost;
            if (starBalance >= currentCost) {
                if(upgrade.level !== undefined && upgrade.level >= upgrade.maxLevel) return;

                starBalance -= currentCost;
                if (upgrade.level === undefined && !upgrade.consumable) {
                    upgrade.purchased = true;
                }
                upgrade.purchase();
                updateUI();
                if (key === 'autoPlay') toggleAutoPlayState();
                if (key.startsWith('speed')) updateAnimationSpeed();
            }
        }
        
        function handleSellClick(key) {
            const upgrade = upgrades[key];
            if (upgrade.level === undefined || upgrade.level <= 0) return;

            const costOfLastLevel = upgrade.cost(); 
            upgrade.level--;
            const costOfNewLevel = upgrade.cost(); 
            const refundAmount = Math.floor((costOfLastLevel - costOfNewLevel) * 0.75); 
            
            starBalance += refundAmount;

            if (key === 'speed') gameSpeed -= 1;
            if (key === 'addGameBoard') {
                const boardToRemove = gameBoards.pop();
                if (boardToRemove) boardToRemove.element.remove();
                adjustBoardLayout();
            }
            
            updateUI();
            if (key === 'speed') updateAnimationSpeed();
        }

        function processBulkGames() {
            const now = performance.now();
            const delta = (now - lastTick) / 1000;
            lastTick = now;

            if (!hasEnergy()) {
                stopAutoPlayInterval();
                return;
            }
            
            const boardMultiplier = isMetaBoardActive ? 9 : gameBoards.length;
            const gamesToPlay = gameSpeed * boardMultiplier * delta;
            const energyToConsume = Math.min(energy + reserveEnergy, gamesToPlay);
            consumeEnergy(energyToConsume);
            totalGamesPlayed += energyToConsume;

            const wins = energyToConsume * winChance;
            const roundedWins = Math.floor(wins) + (Math.random() < (wins % 1) ? 1 : 0);
            
            const starGain = roundedWins * starMultiplier;
            starBalance += starGain;
            totalStarsEarned += starGain;

            if (isMetaBoardActive) {
                quantumFoam = Math.min(MAX_QUANTUM_FOAM, quantumFoam + gamesToPlay);
            }
            
            if (!isMetaBoardActive) {
                gameBoards.forEach(board => {
                    const randomChoice1 = choices[Math.floor(Math.random() * 3)];
                    board.computerEl.innerHTML = `<i data-lucide="${iconMap[randomChoice1]}" class="lucide-lg text-slate-400"></i>`;
                    board.playerEl.innerHTML = `<i data-lucide="${iconMap[choices[Math.floor(Math.random() * 3)]]}" class="lucide-lg text-slate-400"></i>`;
                });
                lucide.createIcons();
            }

            updateUI();
        }

        function collapseFoam() {
            if (quantumFoam < MAX_QUANTUM_FOAM) return;
            
            const bonus = Math.floor(getSPS() * 10);
            addStars(bonus);
            quantumFoam = 0;
            
            const metaBoard = document.getElementById('meta-board');
            if(metaBoard) {
                metaBoard.classList.add('pop-item');
                setTimeout(() => metaBoard.classList.remove('pop-item'), 500);
            }
            updateUI();
        }

        function restartAutoPlay() {
            clearInterval(autoPlayInterval);
            const processInterval = (gameSpeed >= HYPER_SPEED_THRESHOLD || isMetaBoardActive) ? 100 : (1.2 / gameSpeed * 1000) + 450;
            
            autoPlayInterval = setInterval(() => {
                if (gameSpeed >= HYPER_SPEED_THRESHOLD || isMetaBoardActive) {
                    processBulkGames();
                } else {
                    gameBoards.forEach(board => {
                        if(!board.isAnimating) playGame(choices[Math.floor(Math.random() * 3)], board);
                    });
                }
            }, processInterval / (isMetaBoardActive ? 1 : gameBoards.length));
        }

        function manageAutoPlay() {
            if (autoPlayWantsToRun && !autoPlayInterval && hasEnergy()) {
                choiceButtons.forEach(btn => btn.disabled = true);
                upgrades.autoPlay.element.classList.add('toggled', 'pulse');
                lastTick = performance.now();
                restartAutoPlay();
            } else if (!autoPlayWantsToRun && autoPlayInterval) {
                stopAutoPlayInterval();
                upgrades.autoPlay.element.classList.remove('toggled', 'pulse');
            }
        }
        
        function stopAutoPlayInterval() {
            if (!autoPlayInterval) return;
            clearInterval(autoPlayInterval);
            autoPlayInterval = null;
            upgrades.autoPlay.element.classList.remove('pulse');
            if (!isMetaBoardActive) {
                choiceButtons.forEach(btn => btn.disabled = !hasEnergy());
                gameBoards.forEach(board => {
                    board.computerEl.innerHTML = '';
                    board.playerEl.innerHTML = '';
                    board.computerRing.classList.remove('visible');
                });
            }
        }

        function toggleAutoPlayState() {
            autoPlayWantsToRun = !autoPlayWantsToRun;
            if(autoPlayWantsToRun) {
                 upgrades.autoPlay.element.classList.add('toggled');
            } else {
                 upgrades.autoPlay.element.classList.remove('toggled');
            }
            manageAutoPlay();
        }
        
        function toRoman(num) {
            if (num < 1) return "";
            const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
            let str = '';
            for (let i of Object.keys(roman)) {
                let q = Math.floor(num / roman[i]);
                num -= q * roman[i];
                str += i.repeat(q);
            }
            return str;
        }

        const tallySVGs = {
            1: `<svg width="8" height="16" viewBox="0 0 8 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>`,
            2: `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M12 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>`,
            3: `<svg width="24" height="16" viewBox="0 0 24 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M12 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M20 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>`,
            4: `<svg width="32" height="16" viewBox="0 0 32 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M12 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M20 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M28 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>`,
            5: `<svg width="34" height="16" viewBox="0 0 34 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M12 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M20 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M28 2V14" stroke="white" stroke-width="2" stroke-linecap="round"/><path d="M2 13L32 3" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>`
        };

        function generateCostVisual(cost) {
            let html = `<div class="flex items-center gap-2"><i data-lucide="star" class="w-4 h-4 text-white fill-current"></i><span class="font-bold text-lg">×</span>`;
            if (cost === 0) return 'Gratis';
            if (cost >= 10) {
                html += `<span class="font-mono text-lg">${toRoman(cost)}</span>`;
            } else {
                html += `<div class="flex items-center gap-1">`;
                let remaining = cost;
                while(remaining > 0) {
                    if (remaining >= 5) {
                        html += tallySVGs[5];
                        remaining -= 5;
                    } else {
                        if(tallySVGs[remaining]) html += tallySVGs[remaining];
                        remaining = 0;
                    }
                }
                html += `</div>`;
            }
            html += `</div>`;
            return html;
        }

        function showTooltip(element, key) {
            if (key === 'choice') return;
            const upgrade = upgrades[key];
            if (!upgrade || (upgrade.purchased && !upgrade.consumable && !upgrade.level) || (upgrade.level >= upgrade.maxLevel)) return;
            
            const cost = typeof upgrade.cost === 'function' ? upgrade.cost() : upgrade.cost;
            tooltip.innerHTML = generateCostVisual(cost);
            
            lucide.createIcons();
            
            const rect = element.getBoundingClientRect();
            tooltip.style.display = 'block';
            tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
            tooltip.style.top = `${rect.top - tooltip.offsetHeight - 8}px`;
            tooltip.style.opacity = '1';
        }

        function hideTooltip() {
            tooltip.style.opacity = '0';
            setTimeout(() => { tooltip.style.display = 'none'; }, 200);
        }

        // --- DEBUG FUNCTIONS ---
        function addStars(amount) {
            starBalance += amount;
            totalStarsEarned += amount;
            updateUI();
        }
        function changeSpeed(amount) {
            const currentLevel = upgrades.speed.level;
            const newLevel = currentLevel + amount;
            if (newLevel >= 0 && newLevel <= upgrades.speed.maxLevel) {
                upgrades.speed.level = newLevel;
                gameSpeed = 1 + newLevel;
                updateAnimationSpeed();
                updateUI();
            }
        }

        init();
    </script>
</body>
</html>
